---
title: "DATA 621 Homework #5"
author: "Critical Thinking Group 3"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
    toc_depth: 4
    code_folding: "hide"
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment=NA, message=FALSE, warning=FALSE)
library(tidyverse)
library(kableExtra)
library(caret)
library(RColorBrewer)
library(corrplot)
library(gridExtra)
options(scipen = 999)
```

```{r data, echo=FALSE}
df <- read.csv("./data/wine-training-data.csv")
hold_out_data <- read.csv("./data/wine-evaluation-data.csv")
df <- df[,names(df)[2:length(names(df))]] # Drop the INDEX
predictors <- names(df)[2:length(names(df))]
```

## Introduction 

We have been given a dataset with information on `r nrow(df)` commercially available wines.  The variables in the dataset are mostly related to the chemical properties of the wine being sold.  A large wine manufacturer is studying the data in order to predict the number of wine cases ordered based upon the wine characteristics. If the wine manufacturer can predict the number of cases, then that manufacturer will be able to adjust their wine offering to maximize sales.  The objective is explore, analyze and build a count regression model to predict the number of cases of wine that will be sold given certain properties of the wine. 

## Data Exploration & Preparation

As previously stated we have `r nrow(df)` observations for developing the model.  The evaluation dataset (which we will set aside for now) consists of `r nrow(hold_out_data)` observations.  We will begin by taking a look at the modeling data:

```{r}
summary(df) %>%
  kable() %>%
  kable_styling()
```

Two things jump out about this dataset.  The first thing is that there are variables with negative values.  These negative values don't make sense in the context of chemical properties of wine.  After all, how can you have negative chlorides?  

Second, there are quite a few records with missing values.  We will need to either impute values or drop the records with incomplete data.  These two issues will need to be corrected in the data.

### Correcting Invalid Values

We will begin by correcting the invalid values.  We will assume the negative values were a data entry issue and a negative value was entered when a positive value was desired.  If these negative values were changed into positive numbers, they would be within the range of plausible values based on the other data.

```{r}
fix_negative_values <- function(df){
  df %>%
    mutate(FixedAcidity = abs(FixedAcidity),
           VolatileAcidity = abs(VolatileAcidity),
           CitricAcid = abs(CitricAcid),
           ResidualSugar = abs(ResidualSugar),
           Chlorides = abs(Chlorides),
           FreeSulfurDioxide = abs(FreeSulfurDioxide),
           TotalSulfurDioxide = abs(TotalSulfurDioxide),
           Sulphates = abs(Sulphates),
           Alcohol = abs(Alcohol))
}
df <- fix_negative_values(df)
hold_out_data <- fix_negative_values(hold_out_data)
```

### Missing Values

The instructions indicate that sometimes, the fact that a variable is missing is actually predictive of the target.  Let's see what we can learn about `TARGET` from the missing values.

```{r}
temp <- df %>%
  select(TARGET, STARS, Alcohol, ResidualSugar, Chlorides, FreeSulfurDioxide, TotalSulfurDioxide, pH, Sulphates) %>%
  gather("variable", "value", -TARGET) %>%
  mutate(na = ifelse(is.na(value), "Yes", "No")) %>%
  group_by(TARGET, na, variable) %>%
  tally() %>%
  ungroup()

 temp <- temp %>%
    group_by(variable, na) %>%
    summarise(total = sum(n)) %>%
    merge(temp) %>%
    mutate(share = n / total)
 
 ggplot(temp, aes(TARGET, share, fill = na)) +
   geom_bar(stat = "identity", position = "dodge") +
   scale_fill_brewer(palette = "Set1") +
   facet_wrap(~variable, ncol = 4) + 
   ylab("Percent of Group")
```
 
We learn that the observations that are missing `STARS` are much more likely to have a zero `TARGET`.  So let's look at how many stars wine with a zero `TARGET` have:

```{r}
df %>%
  filter(TARGET == 0) %>%
  select(STARS) %>%
  na.omit() %>%
  group_by(STARS) %>%
  tally() %>%
  kable() %>%
  kable_styling()
```

Based on this it looks like we should assign 1 for all the missing `STARS`.

There is little to no information encoded in the NAs for `Alcohol`,  `ResidualSugar`, `Chlorides`, `FreeSulfurDioxide`, `TotalSulfurDioxide`, `pH`, and `Sulphates`.  We will impute using the median value.

```{r}
fix_missing_values <- function(df){
  df %>%
    mutate(
      ResidualSugar = ifelse(is.na(ResidualSugar), median(ResidualSugar, na.rm = T), ResidualSugar),
      Chlorides = ifelse(is.na(Chlorides), median(Chlorides, na.rm = T), Chlorides),
      FreeSulfurDioxide = ifelse(is.na(FreeSulfurDioxide), median(FreeSulfurDioxide, na.rm = T), FreeSulfurDioxide),
      TotalSulfurDioxide = ifelse(is.na(TotalSulfurDioxide), median(TotalSulfurDioxide, na.rm = T), TotalSulfurDioxide),
      pH = ifelse(is.na(pH), median(pH, na.rm = T), pH),
      Sulphates = ifelse(is.na(Sulphates), median(Sulphates, na.rm = T), Sulphates),
      Alcohol = ifelse(is.na(Alcohol), median(Alcohol, na.rm = T), Alcohol),
      STARS_imputed = ifelse(is.na(STARS), 1, 0),
      STARS = ifelse(is.na(STARS), 1, STARS)
    )
}
df <- fix_missing_values(df)
hold_out_data <- fix_missing_values(hold_out_data)
```

### Training Test Split

Next we will look at splitting the data into a training and testing set at a standard 70-30 split between train and test:

```{r}
set.seed(42)
train_index <- createDataPartition(df$TARGET, p = .7, list = FALSE, times = 1)
train <- df[train_index,]
test <- df[-train_index,]
```

### Univariate Analysis

#### Response Variable

```{r echo=FALSE, message=FALSE, warning=FALSE}
train %>%
  group_by(TARGET) %>%
  tally() %>%
  ggplot(., aes(x = factor(TARGET), y = n, fill = factor(TARGET))) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_brewer(palette = "Set1") + 
  theme(legend.position = "none") +
  labs(x="Number of Wine Cases Purchased (TARGET)",y = "Count")
```

In order to model this as a Poisson process the mean should be equal to the variance

```{r}
train %>%
  summarise(mean = mean(TARGET), variance = var(TARGET)) %>%
  kable() %>%
  kable_styling()
```

They are not the same.  The implications of this requirement not being met is the the $\beta$s are correct but the standard errors will be wrong.

#### Predictors

```{r}
dens <- lapply(predictors, FUN=function(var) {
  ggplot(df, aes_string(x = var)) + 
    geom_density(fill = "gray") +
    geom_vline(aes(xintercept = mean(train[, var])), color = "blue", size=1) +
    geom_vline(aes(xintercept = median(train[, var])), color = "red", size=1) +
    geom_vline(aes(xintercept = quantile(train[, var], 0.25)), linetype = "dashed", size = 0.5) + 
    geom_vline(aes(xintercept = quantile(train[, var], 0.75)), linetype = "dashed", size = 0.5)
  })
do.call(grid.arrange, args = c(dens, list(ncol = 3)))
```

Some of the predictors (the chemical composition variables) are right skewed.


### Bivariate Analysis

Now let's examine the correlations between the variables:

```{r}
corrplot.mixed(cor(train))
```

Hmm.  This suggests that the chemical makeup of the wine has little bearing on the number of cases sold.  The label appeal, acidity index value and star rating have the strongest correlation.  This also suggests that it may be worth the effort to do a better job filling in the missing values in the `STARS` variable.

## Model Building & Evaluation

We will begin by first constructing a count regression model based on the chemical properties of the wine.  So we will be excluding the label, star rating and the acid index as it is a weighted average of the acidity variables.  Based on our bivariate analysis we would not expect this model to preform well.  Since the mean is not equal to the variance we will be using the quasi-Poisson model.

```{r}
train1 <- train %>%
  select(-LabelAppeal, -AcidIndex, -STARS, -STARS_imputed)
model1 <- glm(TARGET ~ ., family = quasipoisson, train1)
summary(model1)
```
